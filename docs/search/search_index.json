{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Giwt is a Java testing framework based on JUnit platform.</p> <p>A Kotlin version (Giwt-kt) is also available.</p> <p>In this documentation, we will use the term Giwt to refer to both versions. But examples will be provided for both languages.</p> <p>Giwt allows developers to write tests in a more readable and understandable way using the <code>given-when-then</code> style.</p> <p>Some libraries such as JGiven or Spock already offer the possibility of writing tests in this style. But depending on the sensitivity of the developer, setting up tests with these libraries can be a little complex.</p> <p>Giwt, by implementing its own test engine, is committed to reducing this complexity.</p>"},{"location":"#example","title":"Example","text":"<p>Here is a simple example of a test written in <code>Giwt</code>:</p> JavaKotlin <pre><code>@Test(\"Parse '123' to integer should give 123\")\nvoid testParse(TestCase&lt;String, Integer&gt; testCase) {\n    testCase\n        .given(\"a string '123'\", \"123\")\n        .when(\"parsing it to integer \", Integer::parseInt)\n        .then(\"the result should be 123\", result -&gt; result.shouldBe(equalTo(123)));\n}\n</code></pre> <pre><code>@Test(\"Parse '123' to integer should give 123\")\nfun testParse(testCase: TestCase&lt;String, Int&gt;) {\n    testCase\n        .given(\"a string '123'\") { \"123\" }\n        .`when`(\"parsing it to int\") { it.toInt() }\n        .then(\"the result should be 123\") { it shouldBe equalTo(123)}\n}\n</code></pre> <p>Note that the test method takes a <code>TestCase</code> parameter. It is the fundamental concept of Giwt. We'll talk about this in more detail later.</p>"},{"location":"#installation","title":"Installation","text":"JavaKotlin <p>Add the following dependency to your <code>pom.xml</code> file:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.imagineDevit&lt;/groupId&gt;\n    &lt;artifactId&gt;giwt&lt;/artifactId&gt;\n    &lt;version&gt;${version}&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p></p> <p>Add the following dependency to your <code>pom.xml</code> file: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.imagineDevit&lt;/groupId&gt;\n    &lt;artifactId&gt;giwt-kt&lt;/artifactId&gt;\n    &lt;version&gt;${version}&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> or if you are using <code>Gradle</code> add the following dependency to your <code>build.gradle</code> file: <pre><code>testImplementation(\"io.github.imagineDevit:giwt-kt:${version}\")\n</code></pre></p>"},{"location":"expectations/","title":"\ud83e\udd1e Expectations","text":"<p>As said before, the <code>TestCaseResult</code> object provides some methods to set some expectations on the result.</p> <p>Depending on the type of the expected result value, different methods are available.</p> <ul> <li>If the expected result is an <code>Ok</code> value, you can use the <code>shouldBe</code>, <code>shouldHave</code> or <code>shouldMatch</code> methods.</li> <li>Otherwise, you can use the <code>shouldFail</code> method.</li> </ul> <p>All these methods take a single argument of type <code>Expectation</code> and return an <code>ExpectationChain</code> object.</p>"},{"location":"expectations/#expectation-object","title":"Expectation object","text":"<p><code>Expectation</code> object is a sealed class that represents the expectation to set on the result of the test case.</p> <p>In another word, it is the condition that the result must satisfy to pass the test.</p> <p>Expectation class has two implementations:</p> <ul> <li><code>Expectation.OnFailure</code> : to set an expectation on an <code>Err</code> value.</li> <li><code>Expectation.OnValue</code> : to set an expectation on an <code>Ok</code> value.</li> </ul>"},{"location":"expectations/#expectationchain-object","title":"ExpectationChain object","text":"<p><code>ExpectationChain</code> object allow you to chain multiple expectations on the result of the test case.</p> <p>It exposes a single method <code>and</code> that takes an <code>Expectation</code> object and returns a new <code>ExpectationChain</code> object.</p>"},{"location":"expectations/#expectations-on-an-ok-value","title":"Expectations on an <code>Ok</code> value","text":"<p>On an <code>Ok</code> value, you can set three types of expectations:</p> <ul> <li> <p><code>shouldBe</code></p> <p>with the following implementations:</p> <ul> <li><code>Null</code> : to check if the result is <code>null</code>.</li> <li><code>NotNull</code> : to check if the result is not <code>null</code>.</li> <li><code>EqualTo</code> : to check if the result is equal to a given value.</li> <li><code>NotEqualTo</code> : to check if the result is not equal to a given value.</li> <li><code>Between</code> : to check if the result is between two values. \u26a0\ufe0f The result must be <code>comparable</code>.</li> <li><code>GreaterThan</code> : to check if the result is greater than a given value. \u26a0\ufe0f The result must be <code>comparable</code>.</li> <li><code>LessThan</code> : to check if the result is less than a given value. \u26a0\ufe0f The result must be <code>comparable</code>.</li> </ul> </li> </ul> JavaKotlin <pre><code>  @Test(\"Parse '123' to integer should give 123\")\n  void testParse(TestCase&lt;String, Integer&gt; testCase) {\n      testCase\n          .given(\"a string '123'\", \"123\")\n          .when(\"parsing it to integer \", Integer::parseInt)\n          .then(\"the result should be 123\", result -&gt; \n              result.shouldBe(notNull()).and(equalTo(123))\n          );\n  }\n</code></pre> <pre><code>    @Test(\"Parse '123' to integer should give 123\")\n    fun testParse(testCase: TestCase&lt;String, Int&gt;) {\n        testCase\n            .given(\"a string '123'\") { \"123\" }\n            .`when`(\"parsing it to int\") { it.toInt() }\n            .then(\"the result should be 123\") { \n                it shouldBe notNull() and equalTo(123) \n            }\n    }\n</code></pre> <ul> <li> <p><code>shouldHave</code></p> <p>with the following implementations:</p> <ul> <li><code>Size</code> : to check if the result has a given size.</li> <li><code>AnItemEqualTo</code> : to check if the result has an item equal to a given value.</li> </ul> </li> </ul> <p>\u26a0\ufe0f The result must be a <code>String</code>, an <code>Iterable</code> or an <code>Array</code>. </p> JavaKotlin <pre><code>  @Test(\"Add 'a' to ['b', 'c'] should give ['b', 'c', 'a']\")\n  void testParse(TestCase&lt;List&lt;String&gt;, List&lt;String&gt; testCase) {\n      testCase\n          .given(\"a list\", List.of(\"b\", \"c\"))\n          .when(\"'a' is added to the list\", list -&gt; {\n              list.add(\"a\");\n              return list;\n          })\n          .then(\"the list should contains 'a'\", result -&gt; \n              result.shouldHave(size(3)).and(anItemEqualTo(\"a\"))\n          );\n  }\n</code></pre> <pre><code>  @Test(\"Add 'a' to ['b', 'c'] should give ['b', 'c', 'a']\")\n  fun testParse(testCase: TestCase&lt;String, Int&gt;) {\n      testCase\n          .given(\"a list\") { listOf(\"b\", \"c\") }\n          .`when`(\"'a' is added to the list\"\") { it.apply { add(\"a\") } }\n          .then(\"the list should contains 'a'\") { \n              it shouldHave size(3) and anItemEqualTo(\"a) \n          }\n  }\n</code></pre> <ul> <li> <p><code>shouldMatch</code></p> <p>with the following implementations:</p> <ul> <li><code>One</code> : to check if the result matches a given predicate.</li> <li><code>All</code> : to check if the result matches all the items of a given list of predicates.</li> <li><code>None</code> : to check if the result matches none of the items of a given list of predicates.</li> </ul> </li> </ul> JavaKotlin <pre><code>  @Test(\"Parse '123' to integer should give 123\")\n  void testParse(TestCase&lt;String, Integer&gt; testCase) {\n      testCase\n          .given(\"a string '123'\", \"123\")\n          .when(\"parsing it to integer \", Integer::parseInt)\n          .then(\"the result should be 123\", result -&gt; \n              result.shouldMatch(all(\n                    Map.of(\n                        \"is not null\", s -&gt; s != null,\n                        \"equal to 123\", s -&gt; s == 123\n                    )\n              ))\n          );\n  }\n</code></pre> <pre><code>    @Test(\"Parse '123' to integer should give 123\")\n    fun testParse(testCase: TestCase&lt;String, Int&gt;) {\n        testCase\n            .given(\"a string '123'\") { \"123\" }\n            .`when`(\"parsing it to int\") { it.toInt() }\n            .then(\"the result should be 123\") { \n                it shouldMatch all(\n                    mapOf(\n                        \"is not null\" to { it != null },\n                        \"equal to 123\" to { it == 123 }\n                    )\n                ) \n            }\n    }\n</code></pre>"},{"location":"expectations/#expectations-on-an-err-value","title":"Expectations on an <code>Err</code> value","text":"<p>On an <code>Err</code> value, you can set only one type of expectation: <code>ShouldFail</code>.</p> <p><code>ShouldFail</code> expectation has two implementations:</p> <ul> <li><code>WithType</code> : to check if the error is an instance of a given type.</li> <li><code>WithMessage</code> : to check if the error message is equal to a given value.</li> </ul> JavaKotlin <pre><code>  @Test(\"try to divide by zero\")\n  void testParse(TestCase&lt;Integer, Integer&gt; testCase) {\n      testCase\n          .given(\"a number\", 3)\n          .when(\"divide it by zero\", i -&gt; i/0)\n          .then(\"result should be a failure\", result -&gt; \n              result\n                .shouldFail(withType(ArithmeticException.class))\n                .and(withMessage(\"/ by zero\"))\n          );\n  }\n</code></pre> <pre><code>    @Test(\"try to divide by zero\")\n    fun testParse(testCase: TestCase&lt;Int, Int&gt;) {\n        testCase\n            .given(\"a snumber\") { 3 }\n            .`when`(\"divide it by zero\") { it/0 }\n            .then(\"the result should be a failure\") { \n                it shouldFail withType(ArithmeticException::class) and withMessage(\"/ by zero\")\n            }\n    }\n</code></pre>"},{"location":"statements/","title":"\ud83d\udccb Statements","text":"<p>Writing a test with Giwt means clearly stating the different stages of the test using the given, when and then statements.</p> <p>Giwt provides three types of statements to describe the test case:</p> <ul> <li>GivenStmt : to describe and supply the input data of the test.</li> <li>WhenStmt : to describe and run the method to test.</li> <li>ThenStmt : to describe and execute assertions on the output data of the test.</li> </ul>"},{"location":"statements/#given-statement","title":"Given statement","text":"<p>The given statement is represented by the <code>GivenStmt</code> class.</p> <p>It is used to describe and supply the input data of the test and to set up the test environment (mocks, stubs, etc.).</p> <p>GivenStmt can be created from a <code>TestCase</code> instance using the <code>given</code> method.</p> <p>It exposes two methods :</p> <ul> <li><code>and</code> : to add one more given statement to the test case. It is useful to set up mocks or stubs.</li> <li><code>when</code> : to create the <code>WhenStmt</code> instance associated with the test case.</li> </ul>"},{"location":"statements/#when-statement","title":"When statement","text":"<p>The when statement is represented by the <code>WhenStmt</code> class.</p> <p>It is used to describe and execute the method to test.</p> <p>WhenStmt can be created from a <code>GivenStmt</code> instance or directly from a <code>TestCase</code> instance using the <code>when</code> method.</p> <p>It exposes a single method <code>then</code> that creates the <code>ThenStmt</code> instance associated with the test case.</p>"},{"location":"statements/#then-statement","title":"Then statement","text":"<p>The then statement is represented by the <code>ThenStmt</code> class.</p> <p>It is used to describe and execute expectations on the output data of the test.</p> <p>ThenStmt can be created from a <code>WhenStmt</code> instance using the <code>then</code> method.</p> <p>It exposes a single method <code>and</code> that add one more then statement to the test case.</p>"},{"location":"testCase/","title":"Test Case","text":"<p>TestCase is the fundamental concept of Giwt.   It allows developers to precisely describe the test case while implementing it.</p> <p>State of play</p> <p>In development, when we write a test, we test the result of executing a function. And a function is a piece of code that takes an input and returns an output.</p> <p>The Giwt TestCase object was designed based on this principle : it is represented as a generic class that takes two type parameters <code>T</code> &amp; <code>R</code> :</p> <p>T : the state</p> <p><code>T</code> is conceptually considered as the type of the test case state.</p> <p>In other words, the type <code>T</code> is the type of the method to test parameter(s).  </p> <p>But a method can have no, one or multiple parameters, so Giwt give you a way to represent them.</p> <ul> <li>When the method to test takes no parameter, use <code>Void</code> (for Java) or <code>Unit</code> (for Kotlin).</li> <li>When the method to test takes one parameter, use the type of this parameter.</li> <li>When the method to test takes multiple parameters, use one of Args object implementation corresponding to the method signature.</li> </ul> <p>Args</p> <p>The <code>Args</code> interface is provided by Giwt to wrap the list of method parameters. It has generic implementations that takes from 2 (<code>Args.Args2</code>) to 10 (<code>Args.Args10</code>) type parameters. For example, if the method signature is <code>void method(String s, int i)</code>, you can use <code>Args2&lt;String, Integer&gt;</code>.</p> <p>R : the result</p> <p><code>R</code> is conceptually considered as the type of the test case result.</p> <p>Since the testCase execution corresponds to the execution of the method to test, <code>R</code> is the return type of this method.</p> <p>\u2139\ufe0f Use <code>Void</code> (for Java) or <code>Unit</code> (for Kotlin) if the method to test returns nothing.</p> <p>After the method to test is executed, the result is wrapped in a <code>TestCaseResult&lt;R&gt;</code> object. </p> <p>TestCaseResult</p> <p>As the test can succeed or fail, the <code>TestCaseResult&lt;R&gt;</code> object also wraps the result into a sealed class <code>ResultValue&lt;R&gt;</code> that can be either <code>Ok&lt;R&gt;</code> or <code>Err&lt;R&gt;</code> in case of success or failure respectively.  <code>TestCaseResult</code> object provides some methods to set some expectations on the result.</p>"}]}